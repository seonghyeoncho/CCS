## 도커 네크워크 구조

도커는 컨테이너 내부 IP를 순타적으로 할당하며, 이 IP는 컨테이너를 재시작할 때마다 변경될 수 있다.
이 내부 IP는 내부 망에서만 쓸 수 있는 IP이므로 외부와 연결이 되어야 한다. 이 과정은 컨테이너를 시작할 떄마다 호스트에 `veth`이라는 네트워크 인터페이스를 생성함으로써 이루어진다. 

도커는 각 컨테이너에 외부와의 네트워크를 제공하기 위해 컨테이너마다 가상 네트워크 인터페이스를 호스트에 생성하며 이 인터페이스의 이름은 `veth`으로 시작한다. 

`veth` 인터페이스는 사용자가 직접 생성할 필요는 없으며 컨테이너가 생성될 때 도커 엔진이 자동으로 생성한다. 

컨테이너를 실행하고 리눅스 사용자라면 `ifconfig`를 명령하면 컨테이너의 수만큼 `veth`로 시작하는 인터페이스가 생성이 된다.

`docker0`라는 브리지도 존재하는데 `docker0` 브리지는 각 `veth` 인터페이스와 바인딩 돼 호스트의 `eth0` 인터페이스와 이어주는 역할을 한다. 

`eth0(container) -> veth... -> docker0 -> eth0(host)`의 구성으로 연뎔이 되어있다. 

`brctl show docker0`을 이용하면 `docker0` 브리지에 실제로 바인딩됐는지 알 수 있다.

## 도터 네트워크 기능

컨테이너를 생성하면 기본적으로 docker0 브리지를 통해 외부와 통신할 수 있는 환경을 사용할 수 있지만 사용자의 선택에 따라 여러 네트워크 드라이버를 쓸 수도 있다. 
도커가 자체적으로 제공하는 대표적인 네트워크 드라이버로는 `bridge`, `host`, `none`, `container`, `overlay`가 잇다. 물론 서드파티들도 존재한다. 

아무런 설정을 하지 않고 컨테이너를 생성하면 컨테이너는 자동으로 `docker0` 브리지를 사용한다.

### 브리지 네트워크

새로운 브리지 네트워크를 생성합니다.

`docker network create --driver bridge [name]`
[name]이라는 브리지 타입의 네트워크가 생성됩니다.

docker run 또는 created에 --net 옵션의 값을 설정하면 컨테이너가 이 네트워크를 사용하도록 설정할 수 있습니다.
```s
docker run -i -it --name [name] \
--net [network_name] \
[image]
```

이렇게 생성된 사용자 정의 네트워크는 `docker network dicconnect, connect`를 통해서 유동적으로 붙이고 뗄 수 있다. 

단 브리지 네트워크, 또는 오버레이 네트워크와 같이 특정 IP 대역을 갖는 네트워크 모드에만 이 명령을 사용할 수 있다.

네트워크의 서브넷, 게이트웨이, IP 할당 범위 등을 임의로 설정하려면 네트워크를 생성할 때 다음 옵션들을 이용하면 된다.

`--subnet` `--ip-range` `--gateway`

단 `--subnet`과 `--ip-range`는 같은 대역이어야 한다.

#### --net-alias

브리지 타입의 네트워크와 `run` 명령어의 `--net-alias` 옵션을 함께 사용하면 특정 호스트 이름으로 컨테이너 여러 개에 접근 할 수 있다.

```s
docker run -i -t -d --name network_alias_contaienr1 \
--net mybridge
--net-alias alicek106 ubuntu
```
```s
docker run -i -t -d --name network_alias_contaienr2 \
--net mybridge
--net-alias alicek106 ubuntu
```
```s
docker run -i -t -d --name network_alias_contaienr3 \
--net mybridge
--net-alias alicek106 ubuntu
```

*-i -t -d 옵션을 함께 사용하면 컨테이너 내부에서 셸을 실행하지만 내부로 들어가지 않으며 컨테이너도 종료되지 않는다. 테스트용으로 컨테이너를 생성할 떄 유용하게 쓸 수 있다.*

첫 번째 컨테이너의 IP 주소가 172.10.0.3이면 나머지 두 컨테이너는 각각 172.18.0.4, 172.18.0.5 이다.

매번 달라지는 IP를 결정하는 것은 별도의 알고리즘이 아닌 **라운드 로빈방식**이다. 이것이 가능한 이유는 도커 엔진에 내장된 DNS가 alicek106이라는 호스트 이름을 `--ne-alias` 옵션으로 alicek106을 설정한 컨테이너로 변환하기 때문이다. 

도커의 DNS는 호스트 이름으로 유동적인 컨테이너를 찾을 때 주로 사용이 된다. 가장 대표적으로 `--link` 옵션으로, 이는 컨테이너의 IP가 변경되어도 별명으로 컨테이너를 찾을 수 있게 DNS에 의해 자동으로 관리된다. 단, 이 경우는 디폴트 브리지 네트워크의 컨테이너 DNS이다. 

`--net-alias` 옵션도 비슷한 원리로 작동된다. 도커는 기본 브리지 네트워크가 아닌 사용자가 정의한 브리지 네크워크에 사용되는 내장 DNS 서버를 가지며, DNS의 IP는 172.0.0.11이다. mybridge라는 네트워크에 속한 3개의 컨테이너는 run으로 생성할 떄 `--net-alias` 옵션에 alicek106이라는 값을 입력했으며, 이 컨테이너의 IP는 DNS 서버에 alicek106이라는 호스트 이름으로 등록된다.

mybirdge 네크워크에 속한 컨테이너에서 alicek106이라는 호스트 이름으로 접근하면 DNS서버는 라운드 로빈 방식을 이용해 컨테이너의 IP 리스트를 반환한다. ping 명령어는 이 IP 리스트에서 천 번째 IP를 사용하므로 매번 다른 IP로 ping을 전송하게 된다.

#### dig

이를 확인하기 위해서 dig라는 도구를 사용할 수 있다. dig는 DNS로 도메인 이름에 대응하는 IP를 조회할 때 사용하는 도구이다. dig는 ubuntu 이미지에 설치돼 있지 않으므로 내부에서 명령어를 통해 설치한다.

```s
apt-get update
apt-get install dnsutils
```

dig 명령어로 alicek106 호스트 이름이 변환되는 IP를 확인한다. 

### 호스트 네트워크

네트워크를 호스트로 설정하면 호스트의 네트워크 환경을 그대로 쓸 수 있다. 호스트의 드라이버는 별도로 생성할 필요없이 기존의 host라는 이름의 네트워크를 사용한다. 

`--net` 옵션을 이용해서 호스트를 설정한 컨테이너의 내부에서 네트워크 환경을 확인하면 호스트와 같은 것을 알 수 있다. 

호스트 머신에서 설정한 호스트 이름도 컨테이너가 물려받기 때문에 컨테이너의 호스트 이름도 도커엔진이 설치된 호스트 머신의 호스트 이름으로 설정된다.

컨테이너 네크워크를 호스트 모드로 설정하면 컨에티너 내부의 애플리케이션을 별도의 포트 포워딩 없이 바로 서비스 할 수 있다. 

### 논 네트워크

말 그대로 아무런 네트워크를 사용하지 않는 것이다. 외부와 연결이 단절된다.

### 컨테이너 네트워크

`--net` 옵션으로 `container`를 입력하면 다른 컨테이너의 네트워크 네임스페이스 환경을 공유할 수 있다. 

공유되는 속성은 내부 IP, 네크워크 인터페이스의 MAC 주소 등이다. 

`--net container:[다른 컨테이너의 ID]`

다른 컨테이너의 네트워크 환경을 공유하면 내부 IP를 새로 할당받지 않으며 호스트에 veth로 시작하는 가상 네트워크 인터페이스도 생성되지 않는다.


### MacVLAN 네트워크

MacVLAN은 호스트의 네트워크 인터페이스 카드를 가상화해 물리 네크워크 환경을 컨테이너에세 동일하게 제공한다. 따라서 MacVLAN을 사용하면 컨테이너는 물리 네트워크상에서 가상의 맥 주소를 가지며, 해당 네트워크에 연결된 다름 장치와의 통신이 가능해진다. MacVLAN에 연결된 컨테이너는 기본적으로 할당되는 IP대역인 172.17.x.x 대신 네트워크 장비의 IP를 할당받기 때문이다. 

*MacVLAN을 사용하는 컨테이너는 기본적으로 호스트와 통신을 할 수 없다.*

